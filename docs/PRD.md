# 스톱밀리 요구사항 정의서 (PRD)

## Project Overview

콩콩팥팥 TV 프로그램에서 영감을 받은 모바일 스톱워치 게임입니다. 플레이어는 두 번의 스톱워치 멈춤으로 얻은 숫자의 뒷자리를 곱하여 가장 높은 점수를 얻는 것을 목표로 합니다.

**핵심 기능:**

- 인원수 설정 (최소 2명, 최대 8명)
- 참가자별 랜덤 동물 캐릭터 분배
- 밀리초 기반 스톱워치 게임 진행
- 점수 계산 및 실시간 표시
- 최종 승자 발표

### 프로젝트 목적 및 목표

- TV 프로그램의 재미있는 게임 경험을 모바일 환경에서 재현합니다.
- 간단하고 직관적인 사용자 인터페이스를 통해 누구나 쉽게 즐길 수 있도록 합니다.
- 친구 또는 가족과 함께 즐길 수 있는 가벼운 파티 게임을 제공합니다.

## Core Functionalities

### 1. 게임 준비 화면 (Game Preparation Screen)

- **기능:**
  - 게임에 참여할 인원수를 설정합니다.
  - 게임의 승패 결정 방식을 선택합니다. (승자 결정: 가장 높은 점수, 패자 결정: 가장 낮은 점수)
  - 동점자 발생 시 재경기 진행 여부를 설정합니다.
- **초기값:** 인원수 3명, 패자 결정 방식, 재경기 가능(활성화)
- **범위:** 인원수 2명 ~ 6명
- **UI:**
  - 화면 중앙에 현재 설정된 인원수가 표시됩니다.
  - 좌우 화살표 버튼을 통해 인원수를 조절합니다.
  - 최소(2명) 또는 최대(6명) 인원에 도달하면 해당 방향의 화살표 버튼이 비활성화됩니다.
  - 인원수 표시 아래에 승자/패자 결정 방식을 선택하는 UI 요소(예: 토글 스위치, 버튼 그룹 등)가 표시됩니다.
  - 승패 결정 방식 아래에 "재경기 가능" 토글 스위치가 표시됩니다. 기본적으로 켜져 있습니다.
  - 하단 '다음' 버튼을 통해 캐릭터 분배 화면으로 이동합니다.

### 2. 캐릭터 분배 화면 (Character Assignment Screen)

- **기능:** 설정된 인원수만큼 랜덤 동물 캐릭터를 각 참가자에게 배정합니다.
- **UI:**
  - 참가자 수만큼 랜덤하게 선택된 동물 캐릭터가 표시됩니다. (초기에는 텍스트, 추후 이미지로 대체)
  - 캐릭터는 그리드 형식으로 정렬되어 표시됩니다.
  - 참가자들에게 각자 동물을 선택하라는 안내 문구가 표시됩니다.
  - 하단 '이전' 버튼으로 인원수 설정 화면으로 돌아가고, '다음' 버튼으로 게임 진행 화면으로 이동합니다.

### 3. 게임 진행 화면 (Gameplay Screen)

- **기능:** 스톱워치 게임을 진행하고 점수를 기록합니다.
- **게임 순서:** 게임 시작 시 플레이어 순서가 랜덤으로 결정됩니다.
- **UI:**
  - 화면 좌측에 플레이어 순서대로 캐릭터 목록이 표시됩니다.
  - 현재 턴인 플레이어의 캐릭터는 강조 표시되고, 아직 턴이 오지 않은 플레이어는 어둡게 표시됩니다.
  - 게임이 종료된 플레이어의 캐릭터 옆에는 획득한 점수가 표시됩니다.
  - 화면 우측에는 스톱워치, 점수판, '시작/멈춤' 버튼이 표시됩니다.
- **게임 방식:**
  1.  "시작하기" 버튼을 누르면 스톱워치가 00:00부터 시작합니다.
  2.  플레이어는 원하는 타이밍에 "정지하기" 버튼을 누릅니다.
  3.  멈춘 시간의 **밀리초 뒷자리 숫자**가 점수판에 첫 번째 숫자로 기록됩니다. (예: 12:58 -> 8)
  4.  다시 "시작하기" 버튼을 누르면 스톱워치가 00:00부터 시작합니다.
  5.  플레이어는 다시 "정지하기" 버튼을 누릅니다.
  6.  멈춘 시간의 **밀리초 뒷자리 숫자**가 점수판에 두 번째 숫자로 기록됩니다. (예: 06:12 -> 2)
  7.  첫 번째, 두 번째 숫자 아래에는 곱셈 연산식과 함께 최종 점수가 표시됩니다. (예: 8 x 2 = 16)
  8.  계산된 점수는 해당 플레이어의 캐릭터 옆에 기록됩니다.
  9.  "시작하기", "정지하기" 버튼 대신 "다음 플레이어" 버튼이 표시됩니다. 해당 버튼을 누르면 다음 플레이어의 턴으로 넘어갑니다.
  10. 마지막 플레이어가 게임을 마치면 "다음 플레이어" 버튼 대신 "결과 보기" 버튼이 표시됩니다.
- **동점자 처리:**
  1. 마지막 플레이어까지 게임을 마친 후, 선택된 게임 모드에 따라 동점자가 발생했는지 확인합니다.
     - 승자 결정 모드: 최고 점수가 동일한 플레이어가 여러 명인 경우
     - 패자 결정 모드: 최저 점수가 동일한 플레이어가 여러 명인 경우
  2. 재경기 가능 옵션이 활성화된 경우:
     - 동점자가 있는 경우, "결과 보기" 버튼 대신 "재경기 시작" 버튼이 표시됩니다.
     - "재경기 시작" 버튼을 누르면 동점자들만 참여하는 재경기가 시작됩니다.
     - 화면 좌측의 플레이어 목록에는 동점자의 캐릭터만 표시됩니다.
     - 다른 플레이어들은 어둡게 표시되거나 숨겨집니다.
     - 동점자들은 원래 게임과 동일한 방식으로 다시 게임을 진행합니다.
     - 재경기 후에도 동점이 발생하면 동점자들 간의 재경기를 반복합니다.
     - 승자 또는 패자가 단독으로 결정되면 "결과 보기" 버튼이 표시되어 결과 확인 화면으로 이동합니다.
  3. 재경기 가능 옵션이 비활성화된 경우:
     - 동점자가 있더라도 "결과 보기" 버튼이 표시됩니다.
     - 동점자들의 결과는 모두 유효하며, 결과 확인 화면에서 모두 표시됩니다.

### 4. 결과 확인 화면 (Result Screen)

- **기능:** 모든 플레이어의 게임이 종료된 후, 설정된 승패 결정 방식에 따라 최종 결과를 발표합니다.
- **UI:**
  - **승자 결정 모드:**
    - 재경기 가능 옵션이 활성화된 경우: 가장 높은 점수를 획득한 플레이어의 캐릭터가 화면 중앙에 표시됩니다.
    - 재경기 가능 옵션이 비활성화된 경우: 가장 높은 점수를 획득한 모든 플레이어의 캐릭터가 화면 중앙에 나란히 표시됩니다.
  - **패자 결정 모드:**
    - 재경기 가능 옵션이 활성화된 경우: 가장 낮은 점수를 획득한 플레이어의 캐릭터가 화면 중앙에 표시됩니다.
    - 재경기 가능 옵션이 비활성화된 경우: 가장 낮은 점수를 획득한 모든 플레이어의 캐릭터가 화면 중앙에 나란히 표시됩니다.
  - 승자/패자를 나타내는 시각적 효과가 표시됩니다.
  - 하단에 '다시하기' 버튼 또는 '처음으로' 버튼을 두어 게임을 재시작하거나 초기 화면으로 돌아갈 수 있도록 합니다. (선택 사항)

## Documentation

### 필요한 패키지와 라이브러리

- `react-native`: 기본 프레임워크
- `Expo`: 개발도구
- `react-navigation/native`, `react-navigation/stack`: 화면 전환 및 네비게이션 관리
- `react-native-vector-icons`: 아이콘 사용 (화살표 등)
- `zustand`: 전역 상태 관리 (참가자 정보, 게임 상태 등)
- `lottie-react-native` 승자 발표 시 애니메이션 효과

## Design Style Guide

- **모던함과 기능성의 조화:** 최신 디자인 트렌드를 반영하면서도 사용자가 핵심 기능(스톱워치 조작, 점수 확인 등)을 쉽고 명확하게 인지하고 사용할 수 있도록 직관적인 디자인을 추구합니다. 불필요한 시각적 요소를 최소화하고 콘텐츠 자체에 집중할 수 있는 환경을 제공합니다.
- **세련된 둥근 모서리:** 앱 내 버튼, 입력 필드, 정보 카드 등 주요 UI 컴포넌트에 일관된 둥근 모서리(rounded corners)를 적용하여 전체적으로 부드럽고 친근한 인상을 전달합니다. 과도하지 않은 곡률 값을 사용하여 세련미를 유지합니다.
- **편안한 시각적 비율:** 요소 간 충분한 여백(padding, margin)을 확보하여 시각적으로 답답하지 않고 편안한 레이아웃을 구성합니다. 텍스트, 아이콘, 버튼 등 각 요소의 크기와 비율을 조화롭게 설정하여 사용자가 정보를 편안하게 인지할 수 있도록 합니다.
- **시각적 안정감:** 일관된 컬러 팔레트, 타이포그래피 스타일, 아이콘 시스템을 앱 전체에 적용하여 통일성 있고 안정적인 사용자 경험을 제공합니다. 화면 전환이나 사용자 인터랙션에 부드러운 애니메이션 효과를 사용하여 시각적 흐름을 자연스럽게 연결합니다.
